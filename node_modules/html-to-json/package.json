{
  "name": "html-to-json",
  "version": "0.5.1",
  "description": "Parses HTML strings into objects using flexible, composable filters.",
  "main": "index.js",
  "scripts": {
    "test": "grunt test"
  },
  "author": {
    "name": "Eric Weber"
  },
  "license": "MIT",
  "dependencies": {
    "bluebird": "^2.9.34",
    "cheerio": "^0.18.0",
    "lodash": "^2.4.2",
    "request": "^2.60.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/prolificinteractive/node-html-to-json"
  },
  "devDependencies": {
    "express": "^4.10.4",
    "grunt": "^0.4.5",
    "grunt-contrib-jshint": "^0.11.2",
    "grunt-jsbeautifier": "^0.2.10",
    "grunt-mocha-test": "^0.12.4",
    "mocha": "^2.0.1",
    "should": "^4.3.0"
  },
  "readme": "# htmlToJson\n\nParses HTML strings into objects using flexible, composable filters.\n\n## Installation\n\n`npm install html-to-json`\n\n## htmlToJson.parse(html, filter, [callback]) -> promise\n\nThe `parse()` method takes a string of HTML, and a filter, and responds with the filtered data. This supports both callbacks and promises.\n\n```javascript\nvar promise = htmlToJson.parse('<div>content</div>', {\n  'text': function ($doc) {\n    return $doc.find('div').text();\n  }\n}, function (err, result) {\n  console.log(result);\n});\n\npromise.done(function (result) {\n  //Works as well\n});\n```\n\n## htmlToJson.request(requestOptions, filter, [callback]) -> promise\n\nThe `request()` method takes options for a call to the [request](https://github.com/request/request) library and a filter, then returns the filtered response body.\n\n```javascript\nvar promise = htmlToJson.request('http://prolificinteractive.com/team', {\n  'images': ['img', function ($img) {\n    return $img.attr('src');\n  }]\n}, function (err, result) {\n  console.log(result);\n});\n```\n\n## htmlToJson.batch(html, dictionary, [callback]) -> promise\n\nPerforms many parsing operations against one HTML string. This transforms the HTML into a DOM only once instead of for each filter in the dictionary, which can quickly get expensive in terms of processing. This also allows you to break your filters up into more granular components and mix and match them as you please.\n\nThe values in the dictionary can be `htmlToJson.Parser` objects, generated methods from `htmlToJson.createMethod`, or naked filters that you might normally pass into `htmlToJson.parse`. For example:\n\n```javascript\nreturn getProlificHomepage().then(function (html) {\n  return htmlToJson.batch(html, {\n    sections: htmlToJson.createParser(['#primary-nav a', {\n      'name': function ($section) {\n        return $section.text();\n      },\n      'link': function ($section) {\n        return $section.attr('href');\n      }\n    }]),\n    offices: htmlToJson.createMethod(['.office', {\n      'location': function ($office) {\n        return $office.find('.location').text();\n      },\n      'phone': function ($office) {\n        return $office.find('.phone').text();\n      }\n    }]),\n    socialInfo: ['#footer .social-link', {\n      'name': function ($link) {\n        return $link.text();\n      },\n      'link': function ($link) {\n        return $link.attr('href');\n      }\n    }]\n  });\n});\n```\n\n## htmlToJson.createMethod(filter) -> function (html, [callback])\n\nGenerates a method that wraps the passed `filter` argument. The generated method takes an HTML string and processes it against that `filter`.\n\n```javascript\nvar parseFoo = htmlToJson.createMethod({\n  'foo': function ($doc) {\n    return $doc.find('#foo').bar();\n  }\n});\n```\n\n## htmlToJson.createParser(filter), new htmlToJson.Parser(filter)\n\nFor the sake of reusability, creates an object with `.parse` and `.request` helper methods, which use the passed filter. For example:\n\n```javascript\nvar linkParser = htmlToJson.parser(['a[href]', {\n  'text': function ($a) {\n    return $a.text();\n  },\n  'href': function ($a) {\n    return $a.attr('href');\n  }\n}]);\n\nlinkParser.request('http://prolificinteractive.com').done(function (links) {\n  //Do stuff with links\n});\n```\n\nis equivalent to:\n\n```javascript\nlinkParser.request('http://prolificinteractive.com', ['a[href]', {\n  'text': function ($a) {\n    return $a.text();\n  },\n  'href': function ($a) {\n    return $a.attr('href');\n  }\n}]).done(function (links) {\n  //Do stuff with links\n});\n```\n\nThe former allows you to easily reuse the filter (and make it testable), while that latter is a one-off.\n\n### parser.parse(html, [callback])\n\nParses the passed html argument against the parser's filter.\n\n### parser.method(html, [callback])\n\nReturns a method that wraps `parser.parse()`\n\n### parser.request(requestOptions, [callback])\n\nMakes a request with the request options, then runs the response body through the parser's filter.\n\n## Filter Types\n\n### Functions\n\nThe return values of functions are mapped against their corresponding keys. Function filters are passed [cheerio](https://github.com/cheeriojs/cheerio) objects, which allows you to play with a jQuery-like interface.\n\n```javascript\nhtmlToJson.parse('<div id=\"foo\">foo</div>', {\n  'foo1': function ($doc, $) {\n    return $doc.find('#foo').text(); //foo\n  }\n}, callback);\n```\n\n### Arrays\n\nArrays of data can be parsed out by either using the .map() method within a filter function or using the shorthand [selector, filter] syntax:\n\n#### .map(selector, filter)\n\nA filter is applied incrementally against each matched element, and the results are returned within an array.\n\n```javascript\nvar html = '<div id=\"items\"><div class=\"item\">1</div><div class=\"item\">2</div></div>';\n\nhtmlToJson.parse(html, function () {\n  return this.map('.item', function ($item) {\n    return $item.text();\n  });\n}).done(function (items) {\n  // Items should be: ['1','2']\n}, function (err) {\n  // Handle error\n});\n```\n\n#### [selector, filter, after]\n\nThis is essentially a short-hand alias for `.map()`, making the filter look more like its output:\n\n```javascript\nvar html = '<div id=\"items\"><div class=\"item\">1</div><div class=\"item\">2</div></div>';\n\nhtmlToJson\n  .parse(html, ['.item', function ($item) {\n    return $item.text();\n  }])\n  .done(function (items) {\n    // Items should be: ['1','2']\n  }, function (err) {\n    // Handle error\n  });\n```\n\nAs an added convenience you can pass in a 3rd argument into the array filter, which allows you to manipulate the results. You can return a promise if you wish to do an asynchronous operation.\n\n```javascript\nvar html = '<div id=\"items\"><div class=\"item\">1</div><div class=\"item\">2</div></div>';\n\nhtmlToJson\n  .parse(html, ['.item', function ($item) {\n    return +$item.text();\n  }, function (items) {\n    return _.map(items, function (item) {\n      return item * 3;\n    });\n  }])\n  .done(function (items) {\n    // Items should be: [3,6]\n  }, function (err) {\n    // Handle error\n  });\n```\n\n### Asynchronous filters\n\nFilter functions may also return promises, which get resolved asynchronously.\n\n```javascript\nfunction getProductDetails (id, callback) {\n  return htmlToJson.request({\n    uri: 'http://store.prolificinteractive.com/products/' + id\n  }, {\n    'id': function ($doc) {\n      return $doc.find('#product-details').attr('data-id');\n    },\n    'colors': ['.color', {\n      'id': function ($color) {\n        return $color.attr('data-id');\n      },\n      'hex': function ($color) {\n        return $color.css('background-color');\n      }\n    }]\n  }, callback);\n}\n\nfunction getProducts (callback) {\n  return htmlToJson.request({\n    uri: 'http://store.prolificinteractive.com'\n  }, ['.product', {\n    'id': function ($product) {\n      return $product.attr('data-id');\n    },\n    'image': function ($product) {\n      return $product.find('img').attr('src');\n    },\n    'colors': function ($product) {\n      // This is where we use a promise to get the colors asynchronously\n      return this\n        .get('id')\n        .then(function (id) {\n          return getProductDetails(id).get('colors');\n        });\n    }\n  }], callback);\n}\n```\n\n### Dependencies on other values\n\nFilter functions may use the `.get(propertyName)` to use a value from another key in that filter. This returns a promise representing the value rather than the value itself.\n\n```javascript\nfunction getProducts (callback) {\n  return htmlToJson.request('http://store.prolificinteractive.com', ['.product', {\n    'id': function ($product) {\n      return $product.attr('data-id');\n    },\n    'image': function ($product) {\n      return $product.find('img').attr('src');\n    },\n    'colors': function ($product) {\n      // Resolve 'id' then get product details with it\n      return this\n        .get('id')\n        .then(function (id) {\n          return getProductDetails(id).get('colors');\n        });\n    }\n  }], callback);\n}\n```\n\n### Objects\n\nNested objects within a filter are run against the same HTML context as the parent filter.\n\n```javascript\nvar html = '<div id=\"foo\"><div id=\"bar\">foobar</div></div>';\n\nhtmlToJson.parse(html, {\n  'foo': {\n    'bar': function ($doc) {\n      return $doc.find('#bar').text();\n    }\n  }\n});\n```\n\n#### $container modifier\n\nYou may specify a more specific DOM context by setting the $container property on the object filter:\n\n```javascript\nvar html = '<div id=\"foo\"><div id=\"bar\">foobar</div></div>';\n\nhtmlToJson.parse(html, {\n  'foo': {\n    $container: '#foo',\n    'bar': function ($foo) {\n      return $foo.find('#bar').text();\n    }\n  }\n});\n```\n\n### Constants\n\nStrings, numbers, and null values are simply used as the filter's value. This especially comes in handy for incrementally converting from mock data to parsed data.\n\n```javascript\nhtmlToJson.parse('<div id=\"nada\"></div>', {\n  x: 1,\n  y: 'string value',\n  z: null\n});\n```\n\n## Contributing\n\nFirst make sure you have the grunt command line installed globally:\n\n`sudo npm install -g grunt-cli`\n\n### Running Tests\n\nTests are written in mocha and located in the `test` directory. Run them with grunt:\n\n`grunt test`\n\n### Code Standards\n\n#### Linting\n\nBefore committing, run `grunt lint` and fix any warnings.\n\n#### Style\n\nBefore committing, make sure to run `grunt beautify`.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/prolificinteractive/node-html-to-json/issues"
  },
  "_id": "html-to-json@0.5.1",
  "dist": {
    "shasum": "d745da6bfc177231f1b0dedc9ea682fd4e8614df"
  },
  "_from": "html-to-json@",
  "_resolved": "https://registry.npmjs.org/html-to-json/-/html-to-json-0.5.1.tgz"
}
